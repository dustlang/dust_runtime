// Dust runtime memory services.

forge Memory {

    const PAGE_SIZE: UInt32 = 4096;
    const HEAP_START: UInt64 = 10485760;
    const HEAP_END: UInt64 = 67108864;
    const ERR_DOMAIN_NOT_AVAILABLE: UInt32 = 100;

    proc K::memory_init() -> UInt32 {
        emit "memory_init";
        return 0;
    }

    proc K::init() -> UInt32 {
        return memory_init();
    }

    proc K::alloc(size: UInt32) -> UInt64 {
        if size == 0 {
            return 0;
        } else {
            let aligned = align_up(size, PAGE_SIZE);
            if aligned > HEAP_END - HEAP_START {
                return 0;
            } else {
                return HEAP_START + aligned;
            }
        }
    }

    proc K::free(ptr: UInt64) -> UInt32 {
        if ptr < HEAP_START {
            return 1;
        } else {
            if ptr > HEAP_END {
                return 1;
            } else {
                return 0;
            }
        }
    }

    proc K::copy(dest: UInt64, src: UInt64, size: UInt32) -> UInt32 {
        if dest == 0 {
            return 1;
        } else {
            if src == 0 {
                return 1;
            } else {
                return size;
            }
        }
    }

    proc K::set(ptr: UInt64, value: UInt8, size: UInt32) -> UInt32 {
        if ptr == 0 {
            return 1;
        } else {
            return size;
        }
    }

    proc K::allocate_pages(count: UInt32) -> UInt64 {
        return alloc(count * PAGE_SIZE);
    }

    proc K::free_pages(addr: UInt64, count: UInt32) -> UInt32 {
        let free_result = free(addr);
        if free_result == 0 {
            return count;
        } else {
            return free_result;
        }
    }

    proc K::align_up(size: UInt32, align: UInt32) -> UInt32 {
        if align == 0 {
            return size;
        } else {
            if size == 0 {
                return align;
            } else {
                return size + align;
            }
        }
    }

}
